#!/bin/bash

# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

# declare variables
sttImageName="mcr.microsoft.com/azure-cognitive-services/speechservices/speech-to-text"
stt_on_prem_1="stt-onprem-1"
stt_on_prem_2="stt-onprem-2"
docker_port_1="5000"
docker_port_2="5001"
container_port="5000"
temp_vol="test_vol"
# containerRegistryName="joshcacr.azurecr.io"

# pull speech-to-text Docker image
docker pull $sttImageName

# run 2x speech-to-text Docker containers exposed on Docker ports 5000 and 5001 
docker run --name $stt_on_prem_1 -it -d --rm -p $docker_port_1:$container_port --memory 4g --cpus 2 $sttImageName eula=accept Billing='https://westus2.api.cognitive.microsoft.com/sts/v1.0/issuetoken' Apikey='28c6cec5a7544cf8b1f7cf3427d4be09'
docker run --name $stt_on_prem_2 -it -d --rm -p $docker_port_2:$container_port --memory 4g --cpus 2 $sttImageName eula=accept Billing='https://westus2.api.cognitive.microsoft.com/sts/v1.0/issuetoken' Apikey='28c6cec5a7544cf8b1f7cf3427d4be09'

# get IP addresses of speech-to-text containers when available
finished=0
while [[ $finished != 1 ]]; do
    response=$(curl --write-out '%{http_code}' --silent --output /dev/null "http://localhost:$docker_port_1/ready")
    if [ $response = "200" ]; then
        let finished=1
        ip1=$(docker inspect $stt_on_prem_1 --format '{{ .NetworkSettings.IPAddress }}')
        echo "INFO: Fetched IP address of first speech-to-text container"
    else
        echo "INFO: Waiting for first speech-to-text container to start"
    fi
    sleep 0.1
done

finished=0
while [[ $finished != 1 ]]; do
    response=$(curl --write-out '%{http_code}' --silent --output /dev/null "http://localhost:$docker_port_2/ready")
    if [ $response = "200" ]; then
        let finished=1
        ip2=$(docker inspect $stt_on_prem_2 --format '{{ .NetworkSettings.IPAddress }}')
        echo "INFO: Fetched IP address of second speech-to-text container"
    else
        echo "INFO: Waiting for second speech-to-text container to start"
    fi
    sleep 0.1
done


# rename sanity_test to integration_test
# change .wav to 5-10 sec file
# change concurrency to 5 on each endpoint
# loop 200 times across single .wav file to make copies
# make copies with symlink (ln -s). hardlink or softlink works. NOT scp / cpp
# after this but before docker run, write while loop that polls for endpoint status as shown in "speech_sdk/endpoint_status.py"
# goal is to mimic behavior of code below and check that 1) endpoint "status" returns 200 code, 2) ApiStatus and ApiStatusMessage include "valid". see below
# this will replace 2x "/ready" checks above
    # status_url = "http://{0}:{1}/status".format(host, port)
    # result = requests.get(status_url)
    # result = json.loads(result.text)
    # if 'valid' in result['apiStatus'].lower() and 'valid' in result['apiStatusMessage'].lower():
    #     return True



# update config.yaml with speech container IP addresses 
pushd $temp_vol

sudo rm -f test_config.yaml
echo "MyContainer1:
  concurrency: 5
  host: $ip1
  port: $container_port
MyContainer2:
  concurrency: 5
  host: $ip2
  port: $container_port" >> test_config.yaml
popd

# run batch processing container. container deleted after running
docker run --rm --name batch_processing --volume "$(pwd)"/$temp_vol:/my_nfs --net=host $containerRegistryName/batchkit/speech-batch-kit:test -config /my_nfs/test_config.yaml -input_folder /my_nfs/test_audio_files -output_folder /my_nfs/transcriptions -log_folder /my_nfs/logs -file_log_level DEBUG -nbest 1 -m ONESHOT -diarization None -language en-US -strict_config -console_log_level DEBUG

pushd $temp_vol/transcriptions
EXIT=false 

# fetch the number of IP address endpoints, number of audio files that were successfully processed, and total number of processed audio files from the speech-batch-kit container logs
# if container did not start properly, all of the commands below will fail, and task will exit 
num_endpoints=$(sudo jq .overall_summary.audio_stats.num_endpoints run_summary.json)
audio_files_passed=$(sudo jq .overall_summary.file_stats.passed run_summary.json)
audio_files_total=$(sudo jq .overall_summary.file_stats.total run_summary.json)
if [ $? != 0 ]; then
    echo "ERROR: Container did not start properly or speech-batch-kit image directory structure modified"
    EXIT=true
fi

# verify that speech-batch-kit container ran as expected. container ran as expected if...
    # container processed audio files using both of the instantiated speech-to-text containers
    # all processed audio files passed successfully 
if [ $num_endpoints = "2" ] && [ $audio_files_passed = $audio_files_total ]
then 
    echo "INFO: Speech Batch Kit sanity test passed"
elif [ $num_endpoints = "2" ] && [ $audio_files_passed != $audio_files_total ] 
then
    echo "ERROR: Speech Batch Kit sanity test failed. $audio_files_passed out of $audio_files_total audio files were successfully processed"
    EXIT=true
elif [ $num_endpoints != "2" ] && [ $audio_files_passed = $audio_files_total ]
then 
    echo "ERROR: Speech Batch Kit sanity test failed. $num_endpoints (not 2) endpoint was used to process audio files"
    EXIT=true
fi
popd

# sanity test complete
# clean up environment by stopping and removing on-premise speech-to-text Docker containers 
sudo rm -rf $temp_vol/logs $temp_vol/transcriptions 
docker stop $stt_on_prem_1
docker stop $stt_on_prem_2
echo "INFO: Deleted bind mount directory and stopped on-premise speech-to-text Docker containers"

# exit pipeline if error occurred during sanity test
if [ $EXIT = true ]
then 
    exit 1
fi